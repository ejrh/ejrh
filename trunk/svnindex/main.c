/*
 * main.c: Subversion indexer.
 *
 * This program indexes a given revision of a Subversion repository by
 * adding information about the revision (paths changed, etc.) to a
 * PostgreSQL database; it also uses PostgreSQL's tsearch2 to index the
 * text of changed files.
 *
 * Written by Edmund Horner (with source adapted from svnadmin/main.c).
 *
 * ====================================================================
 * Copyright (c) 2000-2004 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */


#include <apr_file_io.h>
#include <apr_signal.h>

#include "svn_pools.h"
#include "svn_cmdline.h"
#include "svn_error.h"
#include "svn_opt.h"
#include "svn_utf.h"
#include "svn_subst.h"
#include "svn_path.h"
#include "svn_config.h"
#include "svn_repos.h"
#include "svn_fs.h"
#include "svn_version.h"
#include "svn_props.h"
#include "svn_time.h"

#include "svn_private_config.h"

/* Declare svnindex__index (from index.c) because I'm too lazy to make a
   header file. */
extern
svn_error_t *
svnindex__index (svn_repos_t *repos,
                 svn_stream_t *feedback_stream,
                 svn_revnum_t start_rev,
                 svn_revnum_t end_rev,
                 svn_boolean_t verbose,
                 const char *db,
                 svn_cancel_func_t cancel_func,
                 void *cancel_baton,
                 apr_pool_t *pool);


/*** Code. ***/

/* A flag to see if we've been cancelled by the client or not. */
static volatile sig_atomic_t cancelled = FALSE;

/* A signal handler to support cancellation. */
static void
signal_handler (int signum)
{
  apr_signal (signum, SIG_IGN);
  cancelled = TRUE;
}


/* A helper to set up the cancellation signal handlers. */
static void
setup_cancellation_signals (void (*handler)(int signum))
{
  apr_signal (SIGINT, handler);
#ifdef SIGBREAK
  /* SIGBREAK is a Win32 specific signal generated by ctrl-break. */
  apr_signal (SIGBREAK, handler);
#endif
#ifdef SIGHUP
  apr_signal (SIGHUP, handler);
#endif
#ifdef SIGTERM
  apr_signal (SIGTERM, handler);
#endif
}


/* Our cancellation callback. */
static svn_error_t *
check_cancel (void *baton)
{
  if (cancelled)
    return svn_error_create (SVN_ERR_CANCELLED, NULL, _("Caught signal"));
  else
    return SVN_NO_ERROR;
}


/* Helper to parse local repository path.  Try parsing next parameter
 * of OS as a local path to repository.  If successfull *REPOS_PATH
 * will contain internal style path to the repository.
 */
static svn_error_t *
parse_local_repos_path (apr_getopt_t *os, 
                        const char ** repos_path, 
                        apr_pool_t *pool)
{
  *repos_path = NULL;

  /* Check to see if there is one more parameter. */
  if (os->ind < os->argc)
    {
      const char * path = os->argv[os->ind++];
      SVN_ERR (svn_utf_cstring_to_utf8 (repos_path, path, pool));
      *repos_path = svn_path_internal_style (*repos_path, pool);
    }

  if (*repos_path == NULL)
    {
      return svn_error_create (SVN_ERR_CL_ARG_PARSING_ERROR, NULL, 
                               _("Repository argument required"));
    }
  else if (svn_path_is_url (*repos_path))
    {
      return svn_error_createf (SVN_ERR_CL_ARG_PARSING_ERROR, NULL,
                                _("'%s' is an URL when it should be a path"),
                                *repos_path);
    }

  return SVN_NO_ERROR;   
}


/* Custom filesystem warning function. */
static void
warning_func (void *baton, 
              svn_error_t *err)
{
  if (! err)
    return;
  svn_handle_error2 (err, stderr, FALSE, "svnindex: ");
}


/* Helper to open a repository and set a warning func (so we don't
 * SEGFAULT when libsvn_fs's default handler gets run).  */
static svn_error_t *
open_repos (svn_repos_t **repos,
            const char *path,
            apr_pool_t *pool)
{
  SVN_ERR (svn_repos_open (repos, path, pool));
  svn_fs_set_warning_func (svn_repos_fs (*repos), warning_func, NULL);
  return SVN_NO_ERROR;
}


/* Version compatibility check */
static svn_error_t *
check_lib_versions (void)
{
  static const svn_version_checklist_t checklist[] =
    {
      { "svn_subr",  svn_subr_version },
      { "svn_repos", svn_repos_version },
      { "svn_fs",    svn_fs_version },
      { "svn_delta", svn_delta_version },
      { NULL, NULL }
    };

  SVN_VERSION_DEFINE (my_version);
  return svn_ver_check_list (&my_version, checklist);
}



/** Subcommands. **/

static svn_opt_subcommand_t
  subcommand_help,
  subcommand_index;

enum 
  { 
    svnindex__version = SVN_OPT_FIRST_LONGOPT_ID,
    svnindex__db
  };

/* Option codes and descriptions.
 *
 * This must not have more than SVN_OPT_MAX_OPTIONS entries; if you
 * need more, increase that limit first. 
 *
 * The entire list must be terminated with an entry of nulls.
 */
static const apr_getopt_option_t options_table[] =
  {
    {"help",          'h', 0,
     N_("show help on a subcommand")},

    {NULL,            '?', 0,
     N_("show help on a subcommand")},

    {"version",       svnindex__version, 0,
     N_("show version information")},

    {"revision",      'r', 1,
     N_("specify revision number ARG (or X:Y range)")},

    {"verbose",  'v', 0,
     N_("be verbose")},

    {"quiet",           'q', 0,
     N_("no progress (only errors) to stderr")},

    {"db",      svnindex__db, 1,
     N_("specify database connect string")},

    {NULL}
  };


/* Array of available subcommands.
 * The entire list must be terminated with an entry of nulls.
 */
static const svn_opt_subcommand_desc_t cmd_table[] =
  {
    {"help", subcommand_help, {"?", "h"},
     N_("usage: svnindex help [SUBCOMMAND...]\n\n"
        "Describe the usage of this program or its subcommands.\n"),
     {svnindex__version} },

    {"index", subcommand_index, {0},
     N_("usage: svnindex index REPOS_PATH --db CONNECT\n\n"
        "Index a revision into a PostgreSQL database using the given connect string.\n"),
     {'r','v',svnindex__db} },

    { NULL, NULL, {0}, NULL, {0} }
  };


/* Baton for passing option/argument state to a subcommand function. */
struct svnindex_opt_state
{
  const char *repository_path;
  svn_opt_revision_t start_revision, end_revision;  /* -r X[:Y] */
  svn_boolean_t help;                               /* --help or -? */
  svn_boolean_t version;                            /* --version */
  svn_boolean_t verbose;                            /* --verbose */
  svn_boolean_t quiet;                              /* --quiet */
  const char *db;
};


/* Set *REVNUM to the revision specified by REVISION (or to
   SVN_INVALID_REVNUM if that has the type 'unspecified'),
   possibly making use of the YOUNGEST revision number in REPOS. */
static svn_error_t *
get_revnum (svn_revnum_t *revnum, const svn_opt_revision_t *revision, 
            svn_revnum_t youngest, svn_repos_t *repos, apr_pool_t *pool)
{
  if (revision->kind == svn_opt_revision_number)
    *revnum = revision->value.number;
  else if (revision->kind == svn_opt_revision_head)
    *revnum = youngest;
  else if (revision->kind == svn_opt_revision_date)
    SVN_ERR (svn_repos_dated_revision
             (revnum, repos, revision->value.date, pool));
  else if (revision->kind == svn_opt_revision_unspecified)
    *revnum = SVN_INVALID_REVNUM;
  else
    return svn_error_create
      (SVN_ERR_CL_ARG_PARSING_ERROR, NULL, _("Invalid revision specifier"));

  if (*revnum > youngest)
    return svn_error_createf
      (SVN_ERR_CL_ARG_PARSING_ERROR, NULL,
       _("Revisions must not be greater than the youngest revision (%ld)"),
       youngest);

  return SVN_NO_ERROR;
}


/* Baton for recode_write(). */
struct recode_write_baton
{
  apr_pool_t *pool;
  FILE *out;
};

/* This implements the 'svn_write_fn_t' interface.

   Write DATA to ((struct recode_write_baton *) BATON)->out, in the
   console encoding, using svn_cmdline_fprintf().  DATA is a
   UTF8-encoded C string, therefore ignore LEN.

   ### This recoding mechanism might want to be abstracted into
   ### svn_io.h or svn_cmdline.h, if it proves useful elsewhere. */
static svn_error_t *recode_write (void *baton,
                                  const char *data,
                                  apr_size_t *len)
{
  struct recode_write_baton *rwb = baton;
  return svn_cmdline_fputs (data, rwb->out, rwb->pool);
}


/* This implements `svn_opt_subcommand_t'. */
static svn_error_t *
subcommand_index (apr_getopt_t *os, void *baton, apr_pool_t *pool)
{
  struct svnindex_opt_state *opt_state = baton;
  svn_repos_t *repos;
  svn_fs_t *fs;
  svn_stream_t *stderr_stream = NULL;
  struct recode_write_baton stderr_stream_rwb = { 0 };
  svn_revnum_t lower = SVN_INVALID_REVNUM, upper = SVN_INVALID_REVNUM;
  svn_revnum_t youngest;

  SVN_ERR (open_repos (&repos, opt_state->repository_path, pool));
  fs = svn_repos_fs (repos);
  SVN_ERR (svn_fs_youngest_rev (&youngest, fs, pool));

  /* Find the revision numbers at which to start and end. */
  SVN_ERR (get_revnum (&lower, &opt_state->start_revision,
                       youngest, repos, pool));
  SVN_ERR (get_revnum (&upper, &opt_state->end_revision,
                       youngest, repos, pool));

  if (lower > upper)
    return svn_error_create
      (SVN_ERR_CL_ARG_PARSING_ERROR, NULL,
       _("First revision cannot be higher than second"));

  /* Progress feedback goes to stderr, unless they asked to suppress
     it. */
  if (! opt_state->quiet)
    {
      stderr_stream = svn_stream_create (&stderr_stream_rwb, pool);
      stderr_stream_rwb.pool = pool;
      stderr_stream_rwb.out = stderr;
      svn_stream_set_write (stderr_stream, recode_write);
    }

  SVN_ERR (svnindex__index (repos,
                            stderr_stream,
                            lower, upper,
                            opt_state->verbose,
                            opt_state->db,
                            check_cancel,
                            NULL,
                            pool));

  return SVN_NO_ERROR;
}


/* This implements `svn_opt_subcommand_t'. */
static svn_error_t *
subcommand_help (apr_getopt_t *os, void *baton, apr_pool_t *pool)
{
  struct svnindex_opt_state *opt_state = baton;
  const char *header =
    _("general usage: svnindex SUBCOMMAND REPOS_PATH  [ARGS & OPTIONS ...]\n"
      "Type 'svnindex help <subcommand>' for help on a specific"
      " subcommand.\n"
      "\n"
      "Available subcommands:\n");

  const char *fs_desc_start
    = _("The following repository back-end (FS) modules are available:\n\n");

  svn_stringbuf_t *version_footer;

  version_footer = svn_stringbuf_create (fs_desc_start, pool);
  SVN_ERR (svn_fs_print_modules (version_footer, pool));

  SVN_ERR (svn_opt_print_help (os, "svnindex", 
                               opt_state ? opt_state->version : FALSE,
                               FALSE, version_footer->data,
                               header, cmd_table, options_table, NULL,
                               pool));
  
  return SVN_NO_ERROR;
}



/** Main. **/

int
main (int argc, const char * const *argv)
{
  svn_error_t *err;
  apr_status_t apr_err;
  apr_allocator_t *allocator;
  apr_pool_t *pool;

  const svn_opt_subcommand_desc_t *subcommand = NULL;
  struct svnindex_opt_state opt_state;
  apr_getopt_t *os;  
  int opt_id;
  apr_array_header_t *received_opts;
  int i;

  /* Initialize the app. */
  if (svn_cmdline_init ("svnindex", stderr) != EXIT_SUCCESS)
    return EXIT_FAILURE;

  /* Create our top-level pool.  Use a seperate mutexless allocator,
   * given this application is single threaded.
   */
  if (apr_allocator_create (&allocator))
    return EXIT_FAILURE;

  apr_allocator_max_free_set (allocator, SVN_ALLOCATOR_RECOMMENDED_MAX_FREE);

  pool = svn_pool_create_ex (NULL, allocator);
  apr_allocator_owner_set (allocator, pool);

  received_opts = apr_array_make (pool, SVN_OPT_MAX_OPTIONS, sizeof (int));

  /* Check library versions */
  err = check_lib_versions ();
  if (err)
    return svn_cmdline_handle_exit_error (err, pool, "svnindex: ");

  /* Initialize the FS library. */
  err = svn_fs_initialize (pool);
  if (err)
    return svn_cmdline_handle_exit_error (err, pool, "svnindex: ");

  if (argc <= 1)
    {
      subcommand_help (NULL, NULL, pool);
      svn_pool_destroy (pool);
      return EXIT_FAILURE;
    }

  /* Initialize opt_state. */
  memset (&opt_state, 0, sizeof (opt_state));
  opt_state.start_revision.kind = svn_opt_revision_unspecified;
  opt_state.end_revision.kind = svn_opt_revision_unspecified;

  /* Parse options. */
  apr_getopt_init (&os, pool, argc, argv);
  os->interleave = 1;

  while (1)
    {
      const char *opt_arg;
      const char *utf8_opt_arg;

      /* Parse the next option. */
      apr_err = apr_getopt_long (os, options_table, &opt_id, &opt_arg);
      if (APR_STATUS_IS_EOF (apr_err))
        break;
      else if (apr_err)
        {
          subcommand_help (NULL, NULL, pool);
          svn_pool_destroy (pool);
          return EXIT_FAILURE;
        }

      /* Stash the option code in an array before parsing it. */
      APR_ARRAY_PUSH (received_opts, int) = opt_id;

      switch (opt_id) {
      case 'r':
        {
          if (opt_state.start_revision.kind != svn_opt_revision_unspecified)
            {
              err = svn_error_create
                (SVN_ERR_CL_ARG_PARSING_ERROR, NULL,
                 _("Multiple revision arguments encountered; "
                   "try '-r M:N' instead of '-r M -r N'"));
              return svn_cmdline_handle_exit_error (err, pool, "svnindex: ");
            }
          if (svn_opt_parse_revision (&(opt_state.start_revision),
                                      &(opt_state.end_revision),
                                      opt_arg, pool) != 0)
            {
              err = svn_utf_cstring_to_utf8 (&utf8_opt_arg, opt_arg,
                                             pool);

              if (! err)
                err = svn_error_createf
                  (SVN_ERR_CL_ARG_PARSING_ERROR, NULL,
                   _("Syntax error in revision argument '%s'"),
                   utf8_opt_arg);
              return svn_cmdline_handle_exit_error (err, pool, "svnindex: ");
            }
        }
        break;
      case 'q':
        opt_state.quiet = TRUE;
        break;
      case 'h':
      case '?':
        opt_state.help = TRUE;
        break;
      case svnindex__version:
        opt_state.version = TRUE;
        opt_state.help = TRUE;
        break;
      case svnindex__db:
        err = svn_utf_cstring_to_utf8 (&opt_state.db, opt_arg,
                                       pool);
        if (err)
          return svn_cmdline_handle_exit_error (err, pool, "svnindex: ");
        break;
      case 'v':
        opt_state.verbose = TRUE;
        break;
      default:
        {
          subcommand_help (NULL, NULL, pool);
          svn_pool_destroy (pool);
          return EXIT_FAILURE;
        }
      }  /* close `switch' */
    }  /* close `while' */
  
  /* If the user asked for help, then the rest of the arguments are
     the names of subcommands to get help on (if any), or else they're
     just typos/mistakes.  Whatever the case, the subcommand to
     actually run is subcommand_help(). */
  if (opt_state.help)
    subcommand = svn_opt_get_canonical_subcommand (cmd_table, "help");

  /* If we're not running the `help' subcommand, then look for a
     subcommand in the first argument. */
  if (subcommand == NULL)
    {
      if (os->ind >= os->argc)
        {
          svn_error_clear
            (svn_cmdline_fprintf (stderr, pool,
                                  _("subcommand argument required\n")));
          subcommand_help (NULL, NULL, pool);
          svn_pool_destroy (pool);
          return EXIT_FAILURE;
        }
      else
        {
          const char *first_arg = os->argv[os->ind++];
          subcommand = svn_opt_get_canonical_subcommand (cmd_table, first_arg);
          if (subcommand == NULL)
            {
              const char* first_arg_utf8;
              err = svn_utf_cstring_to_utf8 (&first_arg_utf8, first_arg, pool);
              if (err)
                return svn_cmdline_handle_exit_error (err, pool, "svnindex: ");
              svn_error_clear
                (svn_cmdline_fprintf (stderr, pool,
                                      _("Unknown command: '%s'\n"),
                                      first_arg_utf8));
              subcommand_help (NULL, NULL, pool);
              svn_pool_destroy (pool);
              return EXIT_FAILURE;
            }
        }
    }

  /* If there's a second argument, it's probably the repository.
     Every subcommand except `help' requires one, so we parse it out
     here and store it in opt_state. */
  if (subcommand->cmd_func != subcommand_help)
    {
      err = parse_local_repos_path (os, 
                                    &(opt_state.repository_path), 
                                    pool);
      if(err)
        {
          svn_handle_error2 (err, stderr, FALSE, "svnindex: ");
          svn_opt_subcommand_help (subcommand->name, cmd_table,
                                   options_table, pool);
          svn_error_clear (err);
          svn_pool_destroy (pool);
          return EXIT_FAILURE;
        }

    }


  /* Check that the subcommand wasn't passed any inappropriate options. */
  for (i = 0; i < received_opts->nelts; i++)
    {
      opt_id = APR_ARRAY_IDX (received_opts, i, int);

      /* All commands implicitly accept --help, so just skip over this
         when we see it. Note that we don't want to include this option
         in their "accepted options" list because it would be awfully
         redundant to display it in every commands' help text. */
      if (opt_id == 'h' || opt_id == '?')
        continue;

      if (! svn_opt_subcommand_takes_option (subcommand, opt_id))
        {
          const char *optstr;
          const apr_getopt_option_t *badopt = 
            svn_opt_get_option_from_code (opt_id, options_table);
          svn_opt_format_option (&optstr, badopt, FALSE, pool);
          svn_error_clear
            (svn_cmdline_fprintf
             (stderr, pool, _("subcommand '%s' doesn't accept option '%s'\n"
                              "Type 'svnindex help %s' for usage.\n"),
              subcommand->name, optstr, subcommand->name));
          svn_pool_destroy (pool);
          return EXIT_FAILURE;
        }
    }

  /* Set up our cancellation support. */
  setup_cancellation_signals (signal_handler);

#ifdef SIGPIPE
  /* Disable SIGPIPE generation for the platforms that have it. */
  apr_signal(SIGPIPE, SIG_IGN);
#endif

  /* Run the subcommand. */
  err = (*subcommand->cmd_func) (os, &opt_state, pool);
  if (err)
    {
      if (err->apr_err == SVN_ERR_CL_ARG_PARSING_ERROR)
        {
          svn_handle_error2 (err, stderr, FALSE, "svnindex: ");
          svn_opt_subcommand_help (subcommand->name, cmd_table,
                                   options_table, pool);
        }
      else
        svn_handle_error2 (err, stderr, FALSE, "svnindex: ");
      svn_error_clear (err);
      svn_pool_destroy (pool);
      return EXIT_FAILURE;
    }
  else
    {
      svn_pool_destroy (pool);
      /* Ensure that everything is written to stdout, so the user will
         see any print errors. */
      err = svn_cmdline_fflush (stdout);
      if (err) {
        svn_handle_error2 (err, stderr, FALSE, "svnindex: ");
        svn_error_clear (err);
        return EXIT_FAILURE;
      }
      return EXIT_SUCCESS;
    }
}
